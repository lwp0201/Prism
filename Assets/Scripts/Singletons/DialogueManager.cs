using System;using System.Collections;using System.Collections.Generic;using TMPro;using UnityEngine;using UnityEngine.Events;using UnityEngine.UI;using Utilities;public class DialogueManager : MonoBehaviour {    public static DialogueManager Instance;    [SerializeField] private AudioClip[] clipsPop;    [SerializeField] private AudioClip clipWorking;    [SerializeField] private AudioClip[] clipsDisappear;    [SerializeField] private Button[] buttons;    [SerializeField] private GameObject cutsceneBoderTop;    [SerializeField] private GameObject cutsceneBoderBottom;    [SerializeField] private GameObject dialoguePanel;    [SerializeField] private GameObject characterUI;    [SerializeField] private GameObject sentenceUI;    private AAnimal owl;    private AAnimal wolf;    private AAnimal bear;    private AAnimal stag;    private AAnimal deer;    private AAnimal boar;    private TextMeshProUGUI characterText;    private TextMeshProUGUI sentenceText;    private int branchIndex;    private bool isChoiceDone;    private AudioSource source;    public void ShowCutsceneBoders() {        StartCoroutine(ToggleBordersCoroutine(true));    }    public void HideCutsceneBorders() {        StartCoroutine(ToggleBordersCoroutine(false));    }    private void Awake() {        if (Instance == null) Instance = this;    }    private void Start() {        characterText = characterUI.GetComponent<TextMeshProUGUI>();        sentenceText = sentenceUI.GetComponent<TextMeshProUGUI>();        HidePanel();        cutsceneBoderTop.SetActive(false);        cutsceneBoderBottom.SetActive(false);        source = Audio.CreateSource(gameObject);        owl = GameManager.Instance.Owl.GetComponent<AAnimal>();        wolf = GameManager.Instance.Wolf.GetComponent<AAnimal>();        bear = GameManager.Instance.Bear.GetComponent<AAnimal>();        stag = GameManager.Instance.Stag.GetComponent<AAnimal>();        deer = GameManager.Instance.Deer.GetComponent<AAnimal>();        boar = GameManager.Instance.Boar.GetComponent<AAnimal>();    }    private void HidePanel() {        dialoguePanel.SetActive(true);        characterText.text = "";        sentenceText.text = "";        dialoguePanel.SetActive(false);        foreach (Button button in buttons) {            button.gameObject.SetActive(false);        }    }    private IEnumerator ToggleBordersCoroutine(bool show, float duration = 1f) {        if (show) {            cutsceneBoderTop.SetActive(true);            cutsceneBoderBottom.SetActive(true);        }        Vector3 startScale = Vector3.one;        startScale.y = show ? 0f : 1f;        Vector3 targetScale = Vector3.one;        targetScale.y = show ? 1f : 0f;        float elapsedTime = 0f;        while (elapsedTime <= duration) {            cutsceneBoderTop.transform.localScale = Vector3.Lerp(startScale, targetScale, elapsedTime / duration);            cutsceneBoderBottom.transform.localScale = Vector3.Lerp(startScale, targetScale, elapsedTime / duration);            yield return null;            elapsedTime += Time.deltaTime;        }        if (!show) {            cutsceneBoderTop.SetActive(false);            cutsceneBoderBottom.SetActive(false);        }    }    public void StartDialogue(string dialogueKey, Action callback, bool isAnimalWorking = false) {        LanguageManager.Dialogue dialogue = LanguageManager.Instance.GetDialogue(dialogueKey);        StartCoroutine(DialogueCoroutine(dialogue, callback, isAnimalWorking));    }    public void StartDialogue(LanguageManager.Dialogue dialogue, Action callback, bool isAnimalWorking = false) {        StartCoroutine(DialogueCoroutine(dialogue, callback, isAnimalWorking));    }    IEnumerator DialogueCoroutine(LanguageManager.Dialogue dialogue, Action callback, bool isAnimalWorking) {        GameManager.LastDialogueTime = Time.time;        dialoguePanel.SetActive(true);        if (isAnimalWorking) {            Audio.PlayAudio(source, clipWorking);        } else {            Audio.PlayAudioRandom(source, clipsPop);        }        List<LanguageManager.Line> lines = dialogue.Lines;        float elapsedTime = 0f;        const float duration = 1f;        Vector3 targetScale = Vector3.one;        dialoguePanel.transform.localScale = Vector3.zero;        while (elapsedTime < duration) {            dialoguePanel.transform.localScale =                Vector3.Lerp(dialoguePanel.transform.localScale, targetScale, elapsedTime);            yield return null;            elapsedTime += Time.deltaTime;        }        for (int i = 0; i < lines.Count; i++) {            LanguageManager.Line line = lines[i];            string charName = line.Character;            List<AAnimal> animals = new List<AAnimal>();            if (charName.Contains("Owl")) {                animals.Add(owl);            }            if (charName.Contains("Wolf")) {                animals.Add(wolf);            }            if (charName.Contains("Bear")) {                animals.Add(bear);            }            if (charName.Contains("Stag")) {                animals.Add(stag);            }            if (charName.Contains("Doe")) {                animals.Add(deer);            }            if (charName.Contains("Boar")) {                animals.Add(boar);            }            foreach (AAnimal animal in animals) {                animal.StartSpeaking();            }            if (charName.Contains("Flower")) {                GameManager.Instance.EnlargeFlower();            }            characterText.text = charName;            if (line.Sentence.Contains("sprite")) {                sentenceText.text = line.Sentence;                yield return new WaitUntil(InputManager.GetSkipDialogue);            } else {                int lengthToShow = 1;                int sentenceLength = line.Sentence.Length;                int charStep = GameManager.Instance.FrameRate > 45f ? 1 : 2;                int count = 0;                while (lengthToShow <= sentenceLength) {                    // support bold, italic and color                    if (line.Sentence[lengthToShow - 1].CompareTo('<') == 0) {                        int startIndex = lengthToShow - 1;                        int endIndex = 0;                        if (line.Sentence.Substring(lengthToShow, 1) == "b") {                            endIndex = line.Sentence.IndexOf("</b>", startIndex, StringComparison.Ordinal) + 4;                            lengthToShow = endIndex + 1;                        } else if (line.Sentence.Substring(lengthToShow, 1) == "i") {                            endIndex = line.Sentence.IndexOf("</i>", startIndex, StringComparison.Ordinal) + 4;                            lengthToShow = endIndex + 1;                        } else if (line.Sentence.Substring(lengthToShow, 5) == "color") {                            endIndex = line.Sentence.IndexOf("</color>", startIndex, StringComparison.Ordinal) + 8;                            lengthToShow = endIndex + 1;                        } else if (line.Sentence.Substring(lengthToShow, 4) == "size") {                            endIndex = line.Sentence.IndexOf("</size>", startIndex, StringComparison.Ordinal) + 7;                            lengthToShow = endIndex + 1;                        }                        if (lengthToShow > sentenceLength) lengthToShow = sentenceLength;                        sentenceText.text = line.Sentence.Substring(0, lengthToShow);                        for (int j = startIndex; j < endIndex; j++) {                            yield return new WaitForSeconds(Time.deltaTime);                        }                    } else {                        sentenceText.text = line.Sentence.Substring(0, lengthToShow);                        count++;                        if (count >= charStep) {                            count = 0;                            yield return null;                        }                    }                    lengthToShow++;//                    //TODO: Softs only//                    if (Input.GetKey(KeyCode.L)) {//                        lengthToShow = sentenceLength;//                        i = lines.Count - 1;//                    }//#if UNITY_EDITOR//                    if (InputManager.GetSkipDialogue()) {//                        lengthToShow = sentenceLength;//                    }////                    if (GameManager.Instance.DebugMode && Input.GetKey(KeyCode.L)) {//                        lengthToShow = sentenceLength;//                        i = lines.Count - 1;//                    }//#endif                }            }            foreach (AAnimal animal in animals) {                animal.StopSpeaking(false);            }            if (i == lines.Count - 1 && dialogue.ChoiceKey != "NULL") {                yield return new WaitUntil(InputManager.GetSkipDialogue);                Coroutine animationCharacterCoroutine = StartCoroutine(AnimateChoiceCoroutine("<sprite name=\"fox_face\"> Fox"));                sentenceText.text = "";                List<LanguageManager.Choice> choices = LanguageManager.Instance.GetChoices(dialogue.ChoiceKey);                isChoiceDone = false;                // show buttons                GameManager.Instance.ShowCursor();                int buttonCount = 0;                for (int j = 0; j < choices.Count; j++) {                    Button button = buttons[j];                    button.gameObject.SetActive(true);                    // set buttons                    button.onClick.RemoveAllListeners();                    var j1 = j;                    button.onClick.AddListener(() => {                        branchIndex = j1;                        isChoiceDone = true;                        StopCoroutine(animationCharacterCoroutine);                    });                    button.transform.GetChild(0).GetComponent<TextMeshProUGUI>().text = j + 1 + ". " + choices[j].Content;                    buttonCount++;                }                // wait for select                yield return new WaitUntil(() => {                    for (int j = 1; j <= buttonCount; j++) {                        KeyCode code = (KeyCode) Enum.Parse(typeof(KeyCode), "Alpha" + j);                        if (Input.GetKeyDown(code)) {                            branchIndex = j - 1;                            isChoiceDone = true;                            StopCoroutine(animationCharacterCoroutine);                        }                    }                    return isChoiceDone;                });                GameManager.Instance.HideCursor();                // hide buttons                foreach (Button button in buttons) {                    button.gameObject.SetActive(false);                }                // moose action should be put up here because there is no "mooseAction" dialogue, it's just an action sequence                if (choices[branchIndex].ResponseKey.Contains("mooseAction")) {                    GameManager.Instance.Moose.GetComponent<Moose>().ShouldRespond = true;                    GameManager.Instance.LogEvent("Dialogue Choice", "Moose No Talking", "Right", 1);                    continue;                }                                // add new lines                dialogue = LanguageManager.Instance.GetDialogue(choices[branchIndex].ResponseKey);                lines.AddRange(dialogue.Lines);                if (choices[branchIndex].ResponseKey.Contains("introResponse1")) {                    // chose "Why me?"                    GameManager.Instance.LogEvent("Dialogue Choice", "Wolf Why Me", "Wrong", 1);                    continue;                }                                if (choices[branchIndex].ResponseKey.Contains("introResponse2")) {                    // chose "I'm in"                    GameManager.Instance.LogEvent("Dialogue Choice", "Wolf I'm In", "Right", 1);                    continue;                }                                if (choices[branchIndex].ResponseKey.Contains("fawnTwinkle")) {                    // chose wrong answer to fawn                    GameManager.Instance.LogEvent("Dialogue Choice", "Fawn GO HOME", "Wrong", 1);                    continue;                }                                if (choices[branchIndex].ResponseKey.Contains("fawnFireflies")) {                    // chose right answer to fawn 1                    GameManager.Instance.LogEvent("Dialogue Choice", "Fawn Fireflies", "Right", 1);                    continue;                }                                if (choices[branchIndex].ResponseKey.Contains("fawnGoHome")) {                    GameManager.Instance.Fawn.GetComponent<Fawn>().ShouldGoHome = true;                    GameManager.Instance.LogEvent("Dialogue Choice", "Fawn Tell Me More", "Right", 1);                    // chose right answer to fawn 2                    continue;                }                                if (choices[branchIndex].ResponseKey.Contains("mooseNoReaction")) {                    // want to be friend with moose by talking                    GameManager.Instance.LogEvent("Dialogue Choice", "Moose Tried Talking", "Wrong", 1);                    continue;                }            } else {                yield return new WaitUntil(InputManager.GetSkipDialogue);            }        }        elapsedTime = 0f;        targetScale = Vector3.zero;        Audio.PlayAudioRandom(source, clipsDisappear);        while (elapsedTime < duration) {            dialoguePanel.transform.localScale =                Vector3.Lerp(dialoguePanel.transform.localScale, targetScale, elapsedTime);            yield return null;            elapsedTime += Time.deltaTime;        }        HidePanel();        callback();    }    private IEnumerator AnimateChoiceCoroutine(string character) {        int dotCount = 1;        while (true) {            string dots = string.Empty;            for (int i = 0; i < dotCount; i++) {                dots += ".";            }            dotCount++;            if (dotCount > 5) dotCount = 1;            characterText.text = character + dots;            yield return new WaitForSeconds(0.8f);        }    }}